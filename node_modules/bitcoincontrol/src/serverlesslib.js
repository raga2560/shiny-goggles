compositekeylib = require('./compositekeylib');
request = require('request');
promise = require('promise');


bitcoin = require('bitcoinjs-lib');
typeforce = require('typeforce');
var bufferReverse = require('buffer-reverse')

var globalcontractinfo;
var globalpartnerinfo;
var globalnetwork;

var globalbalance = 0
var globalspendabletxs = [];
/*
 partnerusage =
 {
	percentpartnerfees: 2, 
	fixedpartnerfees: 100,
        transactionfees: 10, 
 	partneraddress: '',
 }
 partnerreply =
 {
	error: '', // userdata not correct
	msg:'',
	txid: ''
 }

 userdata =
 {
	amountfortransfer: 2, 
	useraddress: '',
        targetaddress: '', 
 	balanceinaddress: '',
 }
 userreply =
 {
	error: '',
	msg:'',
	txid: ''
 }

 contract = 
 {
        maxpartnerfees:'',
        provideraddress: '',
        providerfixedfees: '',
	providerpercentfees: ''
        maximumvalueallowed: '',
	minimumvalueallowed: ''
	
 }


*/

/* Percentages to be got later by contracts  */
/* Get app working with fixed percentages and sender, receiver,addresses, vendorshare, contractorshare  */

function init(contractinfo, partnerinfo, network) 
{
   globalcontractinfo = contractinfo;
   globalpartnerinfo = partnerinfo;
   globalnetwork = network;
}

function determineSendingShareAmount(type, amount, balance, targetaddr, returnaddr)
{
  var fees = Number(globalpartnerinfo.sender.fees);
  var amount = Number(amount);

   var shares = {
	partner: {
	outscriptPubKey: bitcoin.address.toOutputScript(globalpartnerinfo.sender.partneraddress, globalnetwork),
	amount: Number((amount * 0.2).toFixed(0))
	},
	provider: {
	outscriptPubKey: bitcoin.address.toOutputScript(globalcontractinfo.sender.provideraddress, globalnetwork),
	amount: Number((amount * 0.2).toFixed(0))
	},
	target: {
	outscriptPubKey: bitcoin.address.toOutputScript(targetaddr, globalnetwork),
	amount: Number((amount).toFixed(0))
	},
	returnaddr: {
	outscriptPubKey: bitcoin.address.toOutputScript(returnaddr, globalnetwork),
	amount: Number((balance-amount- (amount * 0.4) - fees).toFixed(0))
	}
	
   };
  return shares;
}


function determineRedeemingShareAmount(type, balance, targetaddr)
{
  var fees = Number(globalpartnerinfo.receiver.fees);
  var balance = Number(balance);
  console.log("balance="+balance);

   var shares = {
	partner: {
	outscriptPubKey: bitcoin.address.toOutputScript(globalpartnerinfo.receiver.partneraddress, globalnetwork),
	amount: Number((balance * 0.2).toFixed(0))
	},
	target: {
	outscriptPubKey: bitcoin.address.toOutputScript(targetaddr, globalnetwork),
	amount: Number((balance * (1-0.2-0.2) - fees ).toFixed(0))
	},
	provider: {
	outscriptPubKey: bitcoin.address.toOutputScript(globalcontractinfo.receiver.provideraddress, globalnetwork),
	amount: Number((balance * 0.2) .toFixed(0))
	}
	
   };

  console.log("shares="+JSON.stringify(shares));

  return shares;
}

var url = 'https://api.blockcypher.com/v1/btc/test3/addrs/';

function getbalance (param)
{

var promise = new Promise(function (resolve, reject) {

    request.get(url + param + '/full', function (error, response, body) {
        if (error) {
           reject(error);
        }
        if (typeof body === 'string') {
            body = JSON.parse(body)
        console.log('Body:', body)

	 var txs = body.txs;
         globalbalance = 0;
         globalbalance = body.balance;
         globalspendabletxs = [];
         globalspendabletxs = processtx(txs, param);

        }
    resolve(globalspendabletxs);
    });
  });

  return promise;
}


function dotransactioncheck (param, tx)
{

var promise = new Promise(function (resolve, reject) {

    request.get(url + param + '/full', function (error, response, body) {
        if (error) {
           reject(error);
        }
            body = JSON.parse(body)
        console.log('Body:', body)

	 var txs = body.txs;
         var status = checkiftransactionexists(txs, tx);



    resolve(status);
    });
  });

  return promise;
}

function checkiftransactionexists(globaltxs, tx)
{
 var exists = false;
   for(var i=0; i< globaltxs.length; i++)
   {
     if(globaltxs[i].hash == tx)
        exists = true;
   }
  return exists;
}

function processtx(globaltxs, address)
{
console.log("process", address);
//console.log("globaltxs=", globaltxs);

var spendabletxs = [];

 for(var i=0; i< globaltxs.length; i++)
        {
          var txinput_sameaddress = false;
          var txinput_value = 0;
          for(var j=0; j< globaltxs[i].inputs.length; j++) {
                if(globaltxs[i].inputs[j].addresses[0] == address) {
                        txinput_sameaddress = true;
                        txinput_value =  globaltxs[i].inputs[j].output_value;
                }
          }


          for(var j=0; j< globaltxs[i].outputs.length; j++)
           {
              if(globaltxs[i].confirmations > 2 && !globaltxs[i].outputs[j].spent_by)
             {
                // we are expecting to spend only this address money
                // we are expecting only one transaction output we need to spend
                // This needs change when multiple transaction outputs, need to be spent

                if(globaltxs[i].outputs[j].addresses[0] == address) {
                console.log("value="+globaltxs[i].outputs[j].value);
var txout = {
   index:0,
   tx: '',
   value: '',
   sequence: 0
};

txout.value = globaltxs[i].outputs[j].value;
txout.index = j;
txout.tx = globaltxs[i].hash;
txout.sequence = globaltxs[i].inputs[0].sequence;
spendabletxs.push(txout);
                }

             }
           }
        }


console.log("spendabletxs=", spendabletxs);
 return spendabletxs;
}


function regularSendingFund(type, amount, targetaddr, activatingkeypair)
{

var activatepromise = new Promise(function (resolve, reject) {
    var spendingaddr = activatingkeypair.getAddress() ;
    var returnaddr = spendingaddr;
    console.log("spendingaddr=",spendingaddr);
    var promise = getbalance(spendingaddr );

    promise.then(function(txsreceived) {

    var txb = new bitcoin.TransactionBuilder (globalnetwork);

    var hashType = 1 ;
    if(globalbalance < amount)
    {
	console.log("globalbalance="+globalbalance);
   var status = {
   reason: " No sufficient balance to spend in :"+ spendingaddr,
   status: -1,
   error: '',
   data: '',
   };
    reject(status);
    }

    console.log("globalbalance="+globalbalance);
    var spendoutlist = txsreceived;

   if(spendoutlist.length == 0) {
   var status = {
   reason: "No transactions with confirmation available to spend",
   status: -1,
   error: '',
   data: '',
   };
    reject(status);
    }

   var amountneeded = 0; 

    for(var i=0; i< spendoutlist.length; i++) {
 // We only choose few transaction to spend, instead of all, all-the-time
 // Only first in array is used, later we can change by choosing best transaction to pick
    if(amountneeded < amount) {
    txb.addInput(spendoutlist[i].tx, spendoutlist[i].index, spendoutlist[i].sequence);
       amountneeded += spendoutlist[i].value;
       }
    }

// We have only choose few transactions to spend
// All bitcoin transaction to be spent may not be correct

    var activationshares = determineSendingShareAmount(type, amount, amountneeded, targetaddr, returnaddr)


    console.log(activationshares);
    txb.addOutput(activationshares.partner.outscriptPubKey, activationshares.partner.amount);
    txb.addOutput(activationshares.provider.outscriptPubKey, activationshares.provider.amount);
    txb.addOutput(activationshares.target.outscriptPubKey, activationshares.target.amount);
    txb.addOutput(activationshares.returnaddr.outscriptPubKey, activationshares.returnaddr.amount);

    for(var i=0; i< spendoutlist.length; i++) {
	console.log("beforesign " + i);
	txb.sign(i, activatingkeypair );
    }

   var tx = txb.build();

	console.log("looks ok");
   var status = {
   reason: "Transaction built",
   status: 0,
   error: '',
   data: tx,
   };

   resolve(status);
    }).catch (function(error){

   var status = {
   reason: "Get balance failed",
   status: -1,
   error: error,
   data: tx,
   };

        reject(status);
	console.log("looks catch ok");
    });
  });

  return activatepromise;

}

/*
senderstub = {
 doc_id,
 doc_type,
 doc_hash,
}

veriferstub = {
 doc_id,
 doc_type,
 doc_hash,
}

*/



function doc1Upload(senderstub, uidkey, usagetype  )
{
// type 1, hashofdoc is used in raw string
// type 2, hash of hashofdoc is used in  string
  var Pin = JSON.stringify(senderstub);
  var Pinkey = Buffer.from(Pin);

   var docaddr = compositekeylib.getBufControlCodeAddress(Pinkey, 
		uidkey,
		globalnetwork);
   console.log("docaddr = "+docaddr);

   return docaddr;
}

function doc1CheckAddr(senderstub, uidkey, address  )
{


    var Pin = JSON.stringify(senderstub);
   var Pinkey = Buffer.from(Pin);

    var docaddr = compositekeylib.getBufControlCodeAddress(Pinkey,
                 uidkey,
                 globalnetwork);

    if(docaddr == address) return true;
    else return false;

}

function doc1Checktx(senderstub, uidkey, tx )
{


    var Pin = JSON.stringify(senderstub);
   var Pinkey = Buffer.from(Pin);

    var docaddr = compositekeylib.getBufControlCodeAddress(Pinkey,
                 uidkey,
                 globalnetwork);


var checkingpromise = new Promise(function (resolve, reject) {
     var promise = dotransactioncheck(docaddr );

     promise.then(function(existsornot) {




   resolve(existsornot);
    }).catch (function(error){

        reject(error);
        console.log("looks catch ok");
    });
  });

  return checkingpromise;


}


function compReceiveFund(senderstub, uidkey, targetaddr )
{
// type 1, hashofdoc is used in raw string
// type 2, hash of hashofdoc is used in  string
   
   //return money, to sender after usage
    var Pin = JSON.stringify(senderstub);
   var Pinkey = Buffer.from(Pin);
 
    var docaddr = compositekeylib.getBufControlCodeAddress(Pinkey,
                 uidkey,
                 globalnetwork);

 var type = 1;

var activatepromise = new Promise(function (resolve, reject) {
     var promise = getbalance(docaddr );
 
     promise.then(function(notused) {
 
     var spendoutlist = globalspendabletxs;
 
 
     console.log("globalbalance="+globalbalance);
     var spendoutlist = globalspendabletxs;
   var paytowhom = determineRedeemingShareAmount(type, globalbalance, targetaddr )

   if(globalbalance > 100) {
   var tx = compositekeylib.getAllTransactionForCustomContract(Pinkey, uidkey, spendoutlist, paytowhom, globalnetwork); 

   resolve(tx);
   }
    else{
     resolve(0);
    }
    }).catch (function(error){

        reject(error);
	console.log("looks catch ok");
    });
  });

  return activatepromise;

}

function compReceive1toManyFund(senderstub, uidkey, targetaddr )
{
// type 1, hashofdoc is used in raw string
// type 2, hash of hashofdoc is used in  string
   
   //return money, to sender after usage
    var Pin = JSON.stringify(senderstub);
   var Pinkey = Buffer.from(Pin);
 
    var docaddr = compositekeylib.getBufControlCodeAddress(Pinkey,
                 uidkey,
                 globalnetwork);

 var type = 1;

var activatepromise = new Promise(function (resolve, reject) {
     var promise = getbalance(docaddr );
 
     promise.then(function(notused) {
 
     var spendoutlist = globalspendabletxs;
 
 
     console.log("globalbalance="+globalbalance);
     var spendoutlist = globalspendabletxs;
   var paytowhom = determineRedeemingShareAmount(type, globalbalance, targetaddr)

   if(globalbalance > 100) {
   var tx = compositekeylib.get1toManyTransactionForBufCode(Pinkey, uidkey, spendoutlist, paytowhom, globalnetwork); 

   resolve(tx);
   }
    else{
     resolve(0);
    }
    }).catch (function(error){

        reject(error);
	console.log("looks catch ok");
    });
  });

  return activatepromise;

}

/*
senderstub = {
 doc_id,
 doc_type,
 doc_hash,
 receiverid: '',
 receiverkey: ''
}

receiverstub = {
 doc_id,
 doc_type,
 doc_hash,
 receiverid: '',
 receiverkey: ''
}


*/

function doc2Uploadv(senderstub, uidkey, usagetype )
{
// type 1, hashofdoc is used in raw string

  var Pin = JSON.stringify(senderstub);
  var Pinkey = Buffer.from(Pin);

  var docaddr = compositekeylib.getBufControlCodeAddress(Pinkey, uidkey,
		bitcoin.networks.testnet);
   console.log("address2 = "+addr2);


   return docaddr;
}

function doc2Validate(addr, usagetype,receiverstub, tx, uidkey )
{
// type 1, hashofdoc is used in raw string
// type 2, hash of hashofdoc is used in  string
   // unlock using buffer code
/*
var tx1 = "52a6d4903cd534b1902fdbe3073b5c983a2f59a5d48dff6211b39fdf5b1bac02";
var code = keyPair1.getPublicKeyBuffer();
var indextospend = 0;
var sequence = 141155;
var outscriptPubKey = scriptPubKey;
var amount = 141515;
var tx = compositekeylib.getTransactionForunlockBufCode (code, uidpubKey,  tx1, indextospend, sequence, outscriptPubKey, amount);

console.log(tx.toHex());



   return tx;
*/
}


function sendtx(tx)
{
   var pushtx = {
    tx: tx.toHex()
   };

var config = {
 params: pushtx
};

   var lurl = 'https://api.blockcypher.com/v1/btc/test3/txs/push';
   var promise = new Promise(function (resolve, reject) {
   console.log("before push=", JSON.stringify(pushtx));

   
   request.post(lurl, {body:JSON.stringify(pushtx)} , function (error, response, body) {
        if (error) {
           reject(error);
        }
        resolve(body);
     });

    });

   return promise;
}




module.exports = {
   init: init,
   regularSendingFund: regularSendingFund,
   doc1Upload: doc1Upload,
   doc1Checktx: doc1Checktx,
   doc1CheckAddr: doc1CheckAddr,
   compReceiveFund: compReceiveFund,
   compReceive1toManyFund: compReceive1toManyFund,
   doc2Uploadv: doc2Uploadv,
   sendtx: sendtx,
   doc2Validate: doc2Validate
}
